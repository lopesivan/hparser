.TH "data_input" 3 "Fri Dec 5 2014" "Version hparser-1.0.0" "hparser" \" -*- nroff -*-
.ad l
.nh
.SH NAME
data_input \- 
.PP
Data input source\&.
.PP
This class serves as a generic input interface for data being parsed\&. It provides minimal functionality which can be used in various combinations to handle nearly all imaginable formats of information\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <hparser/data-input\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBinput_section\fP & \fBreceive_input\fP ()=0"
.br
.RI "\fIData input request\&. \fP"
.ti -1c
.RI "virtual bool \fBnext_input\fP (input_count=0)=0"
.br
.RI "\fIBuffer advance request\&. \fP"
.ti -1c
.RI "virtual bool \fBend_of_data\fP () const =0"
.br
.RI "\fIEnd of data check\&. \fP"
.ti -1c
.RI "virtual bool \fBis_terminated\fP () const "
.br
.RI "\fILiteral end of data check\&. \fP"
.ti -1c
.RI "virtual bool \fBreplace_buffer\fP (input_count=0)"
.br
.RI "\fIBuffer replacement request\&. \fP"
.ti -1c
.RI "virtual bool \fBset_input_mode\fP (unsigned int)"
.br
.RI "\fIInput mode change request\&. \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The functions themselves are arbitrary in terms of the library and are provided so that the user has a built-in API to handle data input\&.
.PP
\fBAttention:\fP
.RS 4
This class uses the \fBinput_section\fP class which is entirely implementation-defined by the using program\&. An optional definition is available for simple text input\&. input\&.
.PP
This class uses the \fBcomposite_data\fP class which is entirely implementation-defined by the using program\&. An optional definition is available for simple text processing\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdata_output\fP provides complimentary output functionality\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "virtual const \fBinput_section\fP& data_input::receive_input ()\fC [pure virtual]\fP"
This function should return the next section of input data\&. The size isn't specified so that text parsers can feed lines, tags, 'significant sections' of data, etc\&. Data remains in the buffer until advanced by next_input\&. 
.SS "virtual bool data_input::next_input (input_count = \fC0\fP)\fC [pure virtual]\fP"
This function advances the buffer to the next section of input\&. Until this function is called, receive_input should return the same data on every call\&. The argument provided is for implementation- defined behavior\&. 
.SS "virtual bool data_input::end_of_data () const\fC [pure virtual]\fP"
This function should return true if the end of data has been reached or if an input error has occured\&. Returning true when an error occurs is important for preventing endless input loops\&. 
.PP
Implemented in \fBgeneric_file\fP\&.
.SS "virtual bool data_input::is_terminated () const\fC [virtual]\fP"
This function checks for the literal end of data, whereas, the end_of_data function returns true even in an underrun situation\&. By default, this returns end_of_data\&. 
.SS "virtual bool data_input::replace_buffer (input_count = \fC0\fP)\fC [virtual]\fP"
This function replaces the data currently in the buffer\&. The argument should be used to indicate how much data from the end of the buffer should be replaced\&. 
.SS "virtual bool data_input::set_input_mode (unsignedint)\fC [virtual]\fP"
This function should be used to change the data input mode if more than one mode is needed\&. For example, to switch from a tagged text format to a binary format\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for hparser from the source code\&.
